# 端到端测试 Demo - 用户场景视角

> 文档日期：2026-01-22
> 本文档从用户使用场景出发，展示 Skillix 的端到端测试方案

## 一、Skillix 核心价值

Skillix 是一个技能管理和分发系统，核心流程是：

```
用户需求（自然语言） → 语义理解 → 技能发现/创建 → 技能执行 → 结果反馈
```

### 1.1 与传统代码测试的区别

| 传统代码测试 | Skillix 场景测试 |
|-------------|-----------------|
| 测试函数输入输出 | 测试用户意图到技能匹配 |
| 验证参数校验 | 验证语义理解准确性 |
| 检查文件创建 | 检查技能是否解决问题 |

### 1.2 测试层次

```
┌─────────────────────────────────────────────────────────┐
│ 第一层：用户场景测试（本文档重点）                          │
│ - 用户说什么 → 系统做什么 → 结果是否正确                    │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│ 第二层：工具功能测试（已有测试覆盖）                        │
│ - 技能 CRUD、配置管理、版本控制等                          │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│ 第三层：单元测试（已有测试覆盖）                            │
│ - 文件操作、Markdown 解析、路径处理等                       │
└─────────────────────────────────────────────────────────┘
```

---

## 二、用户场景分析

作为一个 Skillix 用户，我会在以下场景使用系统：

### 场景 1：我有一个新需求，不知道有没有现成技能

```
用户: "我需要把 PDF 文件转成 Markdown 格式"

期望系统行为:
1. 分析用户需求 → 提取关键词: PDF, Markdown, 转换
2. 搜索本地技能 → 查找匹配的技能
3. 搜索技能市场 → 查找可安装的技能
4. 返回推荐结果:
   - 找到匹配技能 → 推荐使用
   - 未找到 → 建议创建新技能
```

### 场景 2：我想创建一个新技能

```
用户: "帮我创建一个代码审查技能"

期望系统行为:
1. 识别用户意图 → 创建技能
2. 引导收集信息:
   - 技能要解决什么问题？
   - 什么情况下触发？
   - 需要哪些具体操作？
3. 生成技能内容
4. 创建技能文件
5. 验证技能可用
```

### 场景 3：我想使用已有技能

```
用户: "用 pdf-converter 技能处理这个文件"

期望系统行为:
1. 查找技能 → 确认存在
2. 加载技能内容
3. 返回技能使用指南
4. 执行技能（如果有脚本）
```

### 场景 4：我想改进现有技能

```
用户: "pdf-converter 技能需要支持批量处理"

期望系统行为:
1. 查找技能 → 确认存在
2. 读取当前内容
3. 分析改进需求
4. 更新技能内容
5. 创建版本备份
```

### 场景 5：我想从市场安装技能

```
用户: "有没有处理 Excel 的技能？帮我安装一个"

期望系统行为:
1. 搜索技能市场
2. 展示匹配结果
3. 用户选择后安装
4. 验证安装成功
```

---

## 三、场景测试 Demo

### Demo 1: 技能发现场景

**用户需求**: "我需要处理 PDF 文件"

```typescript
/**
 * 场景测试：技能发现
 * 
 * 模拟用户描述需求，系统通过语义分析找到匹配技能
 */
describe('场景：技能发现', () => {
  beforeEach(() => {
    setupTestEnv();
    
    // 预置一些技能
    createSkill('pdf-converter', {
      name: 'pdf-converter',
      description: 'PDF 文件转换工具，支持 PDF 转图片、PDF 转文本、PDF 转 Markdown',
      tags: ['pdf', 'converter', 'document'],
    }, '# PDF 转换器\n\n将 PDF 文件转换为其他格式。', 'global');
    
    createSkill('image-processor', {
      name: 'image-processor',
      description: '图片处理工具，支持图片压缩、格式转换',
      tags: ['image', 'processor'],
    }, '# 图片处理器', 'global');
  });

  it('当用户说"我需要处理 PDF 文件"时，应该找到 pdf-converter', () => {
    // 模拟用户输入
    const userRequest = '我需要处理 PDF 文件';
    
    // 调用分流分析
    const result = analyze({
      task: userRequest,
      config: { enableMarketSearch: false },
    });
    
    // 验证：应该找到匹配技能
    expect(result.matchDetails).toBeDefined();
    expect(result.matchDetails!.length).toBeGreaterThan(0);
    
    // 验证：pdf-converter 应该在结果中
    const pdfMatch = result.matchDetails!.find(m => m.name === 'pdf-converter');
    expect(pdfMatch).toBeDefined();
    
    // 验证：匹配分数应该较高
    expect(pdfMatch!.score).toBeGreaterThan(0.3);
    
    // 验证：推荐操作应该是使用现有技能
    if (result.action === 'USE_EXISTING') {
      expect(result.skill).toBe('pdf-converter');
    }
  });

  it('当用户说"转换图片格式"时，应该找到 image-processor', () => {
    const userRequest = '转换图片格式';
    
    const result = analyze({
      task: userRequest,
      config: { enableMarketSearch: false },
    });
    
    const imageMatch = result.matchDetails!.find(m => m.name === 'image-processor');
    expect(imageMatch).toBeDefined();
  });

  it('当用户需求没有匹配技能时，应该建议创建新技能', () => {
    const userRequest = '我需要一个视频剪辑工具';
    
    const result = analyze({
      task: userRequest,
      config: { enableMarketSearch: false },
    });
    
    // 没有视频相关技能，应该建议创建
    expect(result.action).toBe('CREATE_NEW');
  });
});
```

### Demo 2: 技能创建场景

**用户需求**: "帮我创建一个代码审查技能"

```typescript
/**
 * 场景测试：技能创建
 * 
 * 模拟用户描述需求，系统引导创建新技能
 */
describe('场景：技能创建', () => {
  beforeEach(() => {
    setupTestEnv();
  });

  it('应该能根据用户描述创建技能', async () => {
    // 模拟 AI 收集到的用户需求
    const userRequirements = {
      问题: '需要自动审查代码质量',
      触发场景: '当提交 PR 或代码变更时',
      具体操作: '检查代码风格、潜在 bug、安全问题',
      特殊要求: '支持多种编程语言',
    };
    
    // AI 根据需求生成技能参数
    const skillParams = {
      name: 'code-reviewer',
      metadata: {
        name: 'code-reviewer',
        description: `代码审查工具。${userRequirements.触发场景}，${userRequirements.问题}`,
        version: '1.0.0',
        tags: ['code', 'review', 'quality'],
      },
      body: `# 代码审查工具

## 功能描述
${userRequirements.问题}

## 触发场景
${userRequirements.触发场景}

## 具体操作
${userRequirements.具体操作}

## 特殊要求
${userRequirements.特殊要求}
`,
    };
    
    // 创建技能
    const createResponse = await handleCreate({
      ...skillParams,
      scope: 'global',
    });
    
    expect(createResponse.success).toBe(true);
    
    // 验证技能已创建
    const skill = getSkill('code-reviewer');
    expect(skill).not.toBeNull();
    expect(skill!.metadata.description).toContain('代码审查');
    
    // 验证技能可被发现
    const discoverResult = analyze({
      task: '审查代码质量',
      config: { enableMarketSearch: false },
    });
    
    const match = discoverResult.matchDetails?.find(m => m.name === 'code-reviewer');
    expect(match).toBeDefined();
  });

  it('创建的技能应该包含完整的目录结构', async () => {
    await handleCreate({
      name: 'test-skill',
      metadata: {
        name: 'test-skill',
        description: '测试技能，用于验证目录结构',
      },
      body: '# 测试技能',
      scope: 'global',
    });
    
    const skill = getSkill('test-skill');
    expect(skill).not.toBeNull();
    
    // 验证目录结构
    expect(fsUtils.isDirectory(path.join(skill!.path, 'scripts'))).toBe(true);
    expect(fsUtils.isDirectory(path.join(skill!.path, 'references'))).toBe(true);
    expect(fsUtils.isDirectory(path.join(skill!.path, 'assets'))).toBe(true);
    expect(fsUtils.isDirectory(path.join(skill!.path, 'logs'))).toBe(true);
  });
});
```

### Demo 3: 技能使用场景

**用户需求**: "用 pdf-converter 处理文件"

```typescript
/**
 * 场景测试：技能使用
 * 
 * 模拟用户使用已有技能
 */
describe('场景：技能使用', () => {
  beforeEach(() => {
    setupTestEnv();
    
    // 创建一个完整的技能
    createSkill('pdf-converter', {
      name: 'pdf-converter',
      description: 'PDF 文件转换工具',
      version: '1.0.0',
    }, `# PDF 转换器

## 使用方法

1. 准备 PDF 文件
2. 选择输出格式（图片/文本/Markdown）
3. 执行转换

## 支持的格式

- PDF → PNG/JPG
- PDF → TXT
- PDF → MD

## 示例

\`\`\`bash
# 转换为文本
pdf-to-text input.pdf output.txt
\`\`\`
`, 'global');
  });

  it('应该能读取技能的使用指南', async () => {
    const readResponse = await handleRead({ name: 'pdf-converter' });
    
    expect(readResponse.success).toBe(true);
    
    const content = readResponse.data as any;
    expect(content.body).toContain('使用方法');
    expect(content.body).toContain('支持的格式');
    expect(content.body).toContain('示例');
  });

  it('应该能获取技能的完整信息', () => {
    const skill = getSkill('pdf-converter');
    
    expect(skill).not.toBeNull();
    expect(skill!.name).toBe('pdf-converter');
    expect(skill!.metadata.version).toBe('1.0.0');
    expect(skill!.content).toContain('PDF 转换器');
  });
});
```

### Demo 4: 技能改进场景

**用户需求**: "pdf-converter 需要支持批量处理"

```typescript
/**
 * 场景测试：技能改进
 * 
 * 模拟用户改进现有技能
 */
describe('场景：技能改进', () => {
  beforeEach(() => {
    setupTestEnv();
    
    createSkill('pdf-converter', {
      name: 'pdf-converter',
      description: 'PDF 文件转换工具',
      version: '1.0.0',
    }, '# PDF 转换器\n\n单文件转换工具。', 'global');
  });

  it('应该能更新技能并保留版本历史', async () => {
    // 先创建备份
    const skill = getSkill('pdf-converter');
    const backup = createVersionBackup(skill!, '更新前备份');
    expect(backup).not.toBeNull();
    
    // 更新技能
    const updateResponse = await handleUpdate({
      name: 'pdf-converter',
      metadata: {
        name: 'pdf-converter',
        description: 'PDF 文件转换工具，支持批量处理',
        version: '2.0.0',
      },
      body: `# PDF 转换器

## 新功能 (v2.0.0)
- 支持批量处理多个 PDF 文件
- 支持文件夹递归处理

## 使用方法
...
`,
      scope: 'global',
    });
    
    expect(updateResponse.success).toBe(true);
    
    // 验证更新
    const updatedSkill = getSkill('pdf-converter');
    expect(updatedSkill!.metadata.version).toBe('2.0.0');
    expect(updatedSkill!.metadata.description).toContain('批量处理');
    
    // 验证版本历史
    const versions = listVersions(updatedSkill!.path);
    expect(versions.length).toBeGreaterThan(0);
  });

  it('应该能回退到之前的版本', async () => {
    const skill = getSkill('pdf-converter');
    
    // 创建备份
    createVersionBackup(skill!, '原始版本');
    
    // 更新
    await handleUpdate({
      name: 'pdf-converter',
      metadata: { ...skill!.metadata, version: '2.0.0' },
      body: '# 新版本内容',
      scope: 'global',
    });
    
    // 回退
    const rollbackResult = rollbackSkill('pdf-converter', '1.0.0');
    
    expect(rollbackResult.success).toBe(true);
    
    // 验证回退
    const rolledBackSkill = getSkill('pdf-converter');
    expect(rolledBackSkill!.metadata.version).toBe('1.0.0');
  });
});
```

### Demo 5: 技能市场场景

**用户需求**: "有没有处理 Excel 的技能？"

```typescript
/**
 * 场景测试：技能市场
 * 
 * 模拟用户从市场发现和安装技能
 */
describe('场景：技能市场', () => {
  beforeEach(() => {
    setupTestEnv();
    
    // 模拟市场中有技能
    // 注意：实际测试中需要 mock 市场服务
  });

  it('应该能搜索市场中的技能', () => {
    // 模拟市场搜索结果
    const mockMarketResults = [
      {
        name: 'excel-processor',
        description: 'Excel 文件处理工具',
        source: 'awesome-claude-skills',
      },
      {
        name: 'csv-converter',
        description: 'CSV 文件转换工具',
        source: 'awesome-claude-skills',
      },
    ];
    
    // 用户搜索
    const userRequest = '处理 Excel 文件';
    
    // 分析应该返回市场技能
    const result = analyze({
      task: userRequest,
      config: { enableMarketSearch: true },
    });
    
    // 如果有市场匹配，应该建议安装
    if (result.action === 'INSTALL') {
      expect(result.skill).toBeDefined();
      expect(result.source).toBeDefined();
    }
  });

  it('安装后的技能应该可以本地使用', async () => {
    // 模拟安装技能
    const installResult = {
      success: true,
      name: 'excel-processor',
      scope: 'global',
    };
    
    // 如果安装成功，应该能在本地找到
    if (installResult.success) {
      // 创建模拟的已安装技能
      createSkill('excel-processor', {
        name: 'excel-processor',
        description: 'Excel 文件处理工具（从市场安装）',
      }, '# Excel 处理器', 'global');
      
      const skill = getSkill('excel-processor');
      expect(skill).not.toBeNull();
      
      // 应该能被发现
      const discoverResult = analyze({
        task: 'Excel 处理',
        config: { enableMarketSearch: false },
      });
      
      const match = discoverResult.matchDetails?.find(m => m.name === 'excel-processor');
      expect(match).toBeDefined();
    }
  });
});
```

---

## 四、完整用户旅程测试

### Demo 6: 从需求到解决方案的完整旅程

```typescript
/**
 * 完整用户旅程测试
 * 
 * 模拟用户从提出需求到问题解决的完整过程
 */
describe('完整用户旅程', () => {
  beforeEach(() => {
    setupTestEnv();
  });

  it('旅程：发现需求 → 搜索技能 → 未找到 → 创建技能 → 使用技能', async () => {
    // === 第一步：用户提出需求 ===
    const userNeed = '我需要一个工具来分析 Git 提交历史';
    
    // === 第二步：搜索现有技能 ===
    const searchResult = analyze({
      task: userNeed,
      config: { enableMarketSearch: false },
    });
    
    // 验证：没有找到匹配技能
    expect(searchResult.action).toBe('CREATE_NEW');
    
    // === 第三步：创建新技能 ===
    // AI 引导用户收集信息后生成技能
    const newSkillParams = {
      name: 'git-analyzer',
      metadata: {
        name: 'git-analyzer',
        description: 'Git 提交历史分析工具，统计提交频率、贡献者、代码变更',
        version: '1.0.0',
        tags: ['git', 'analyzer', 'statistics'],
      },
      body: `# Git 分析器

## 功能
- 统计提交频率
- 分析贡献者活跃度
- 追踪代码变更趋势

## 使用方法
1. 进入 Git 仓库目录
2. 运行分析命令
3. 查看统计报告
`,
    };
    
    const createResponse = await handleCreate({
      ...newSkillParams,
      scope: 'global',
    });
    
    expect(createResponse.success).toBe(true);
    
    // === 第四步：验证技能可用 ===
    const skill = getSkill('git-analyzer');
    expect(skill).not.toBeNull();
    
    // === 第五步：再次搜索应该能找到 ===
    const searchAgain = analyze({
      task: 'Git 提交分析',
      config: { enableMarketSearch: false },
    });
    
    const match = searchAgain.matchDetails?.find(m => m.name === 'git-analyzer');
    expect(match).toBeDefined();
    expect(match!.score).toBeGreaterThan(0.3);
    
    // === 第六步：使用技能 ===
    const readResponse = await handleRead({ name: 'git-analyzer' });
    expect(readResponse.success).toBe(true);
    expect((readResponse.data as any).body).toContain('统计提交频率');
  });

  it('旅程：发现需求 → 找到技能 → 使用技能 → 改进技能', async () => {
    // === 准备：预置一个技能 ===
    await handleCreate({
      name: 'api-tester',
      metadata: {
        name: 'api-tester',
        description: 'API 接口测试工具',
        version: '1.0.0',
      },
      body: '# API 测试器\n\n基础 API 测试功能。',
      scope: 'global',
    });
    
    // === 第一步：用户提出需求 ===
    const userNeed = '我需要测试 API 接口';
    
    // === 第二步：搜索找到技能 ===
    const searchResult = analyze({
      task: userNeed,
      config: { enableMarketSearch: false },
    });
    
    expect(searchResult.matchDetails?.some(m => m.name === 'api-tester')).toBe(true);
    
    // === 第三步：使用技能 ===
    const readResponse = await handleRead({ name: 'api-tester' });
    expect(readResponse.success).toBe(true);
    
    // === 第四步：用户提出改进需求 ===
    const improvementNeed = 'api-tester 需要支持并发测试';
    
    // === 第五步：更新技能 ===
    const skill = getSkill('api-tester');
    createVersionBackup(skill!, '添加并发测试前');
    
    const updateResponse = await handleUpdate({
      name: 'api-tester',
      metadata: {
        name: 'api-tester',
        description: 'API 接口测试工具，支持并发测试',
        version: '2.0.0',
      },
      body: `# API 测试器

## 功能
- 基础 API 测试
- **并发测试（新增）**

## 并发测试使用方法
设置并发数和请求次数...
`,
      scope: 'global',
    });
    
    expect(updateResponse.success).toBe(true);
    
    // === 第六步：验证改进 ===
    const updatedSkill = getSkill('api-tester');
    expect(updatedSkill!.metadata.version).toBe('2.0.0');
    expect(updatedSkill!.content).toContain('并发测试');
  });
});
```

---

## 五、测试评估标准

### 5.1 语义理解准确性

| 用户输入 | 期望匹配技能 | 匹配分数阈值 |
|---------|-------------|-------------|
| "处理 PDF 文件" | pdf-converter | > 0.3 |
| "转换图片格式" | image-processor | > 0.3 |
| "代码审查" | code-reviewer | > 0.3 |
| "Git 分析" | git-analyzer | > 0.3 |

### 5.2 技能创建完整性

| 检查项 | 验证方法 |
|-------|---------|
| 目录结构完整 | 检查 scripts/references/assets/logs 目录 |
| SKILL.md 存在 | 检查文件存在且内容正确 |
| 元数据正确 | 验证 name/description/version/tags |
| 可被发现 | 创建后能通过搜索找到 |

### 5.3 版本管理正确性

| 检查项 | 验证方法 |
|-------|---------|
| 备份创建 | 检查 .backup 目录 |
| 版本列表 | listVersions 返回正确数量 |
| 回退功能 | rollback 后内容正确 |
| 进化日志 | evolution.log 记录正确 |

---

## 六、运行测试

```bash
# 运行场景测试
npm test -- tests/e2e/

# 运行特定场景
npm test -- tests/e2e/workflow.test.ts -t "场景：技能发现"

# 查看详细输出
npm test -- --reporter=verbose tests/e2e/
```

---

## 七、总结

本文档从用户使用场景出发，设计了以下测试 Demo：

1. **技能发现** - 用户描述需求，系统找到匹配技能
2. **技能创建** - 用户描述需求，系统引导创建新技能
3. **技能使用** - 用户使用已有技能
4. **技能改进** - 用户改进现有技能
5. **技能市场** - 用户从市场发现和安装技能
6. **完整旅程** - 从需求到解决方案的完整过程

这些测试验证了 Skillix 的核心价值：**通过语义理解用户需求，帮助用户发现、创建和使用技能**。
